<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">






<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1">






<meta name="description" content="Go, Bioinfo, Go!">
<meta property="og:type" content="website">
<meta property="og:title" content="BioinfoGo">
<meta property="og:url" content="http://www.bioinfogo.tk/index.html">
<meta property="og:site_name" content="BioinfoGo">
<meta property="og:description" content="Go, Bioinfo, Go!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BioinfoGo">
<meta name="twitter:description" content="Go, Bioinfo, Go!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.bioinfogo.tk/">





  <title>BioinfoGo</title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  







  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=62943161";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>









  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BioinfoGo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-Linux 与编程语言 " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.bioinfogo.tk/2018/12/25/Python 学习笔记-Part4/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kang Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BioinfoGo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/Python 学习笔记-Part4/" itemprop="url">Python 学习笔记-Part4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-25T13:50:30+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux-与编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">Linux 与编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本次学习的内容是关于Python 的函数。<br>与Perl 不太一样，Python 函数的基本格式是将传入参数放在function(parameters) 中的圆括号内，函数代码块是以def 开头，而不是sub。<br>当然，一样的是，返回值是return 进行表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def functionname(parameters):</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    function_suite</span><br><span class="line">    return [expression]</span><br></pre></td></tr></table></figure></p>
<p>函数的调用，相比Perl 更简单，默认就是直接 functionname(parameters)，不需要加”&amp;” 符号。</p>
<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p>这里涉及到Python 的变量及对象的一些概念上的区分，有点绕，但是本质上与Perl 是类似的，只是将我们习以为常的东西解释的更加清楚。</p>
<h2 id="Python中变量与对象的类型"><a href="#Python中变量与对象的类型" class="headerlink" title="Python中变量与对象的类型"></a>Python中变量与对象的类型</h2><p>首先明确一个原则： 在Python中，一切都是对象，类型属于对象，而变量没有类型。<br>变量只是指向某一个对象的引用（Perl）或者指针（C），自身是一个墙头草，没有类型，可以指向列表，可以指向字符串，可以指向数字类型等等。<br>如果有不同的物品，如球和箱子，你可以将标签“A” 贴到箱子上，也可以贴到球上，箱子和球不一样，但是标签A 自身是没有类型的。</p>
<h2 id="可改变与不可改变对象"><a href="#可改变与不可改变对象" class="headerlink" title="可改变与不可改变对象"></a>可改变与不可改变对象</h2><p>继续上一个例子，不同的球就是不同的球，你可以更换一个球，但是不能改变一个球。<br>数字、字符串和元组就是这种球，可以更换标签，但是球一旦产生了，就无法改变，只能丢弃。因此是不能改变的对象，即不可更改对象。<br>而箱子不一样，箱子可以打开，可以装不同的东西，是可以修改的。<br>列表和字典就是箱子，是可以改变的对象，即可更改对象。</p>
<p>具体地，当对于不可改变对象更改赋值时，是把带有标签的球扔掉，重新造出来一个球，再重新写一个标签贴上去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=5;</span><br><span class="line">a=10;</span><br></pre></td></tr></table></figure></p>
<p>就好像我们创造了一个半径为5 cm 的球，贴上了a 标签。然后我们又造了一个半径为10 cm 的球，重新写了一个名字也叫a 的标签贴到10 cm 的球上。<br>那么，如果同时有两个a 的话，我们就不知道哪个球是我们要找的了。所以这个时候，第一个球上的标签a 就被划掉。<br>而这个5 cm 的球（对象），因为标签被划掉，无法被找到，只能被丢弃了。所以实际上不是改变标签a 的形态（值），而是重新生成了一个标签，原有的都丢弃。<br>只是这个新标签也叫a，与之前的标签名字一样罢了。</p>
<p>这里需要注意的是，标签是不能重复利用的。 所以这里是重新生成了标签，而不是把旧标签撕下再粘上。<br>整个处理过程中，球一旦形成就无法改变。</p>
<p>而箱子就不一样了，我们可以在箱子里放不同的东西，贴上标签之后，再往箱子里加东西或者减东西，都是可以的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listA = [1,2,3,4];</span><br><span class="line">listA[2] =5;</span><br></pre></td></tr></table></figure></p>
<p>这里标签list 指向了一个含有四个元素的箱子（类型是列表），然后我可以更换箱子里的元素，或者增加减少元素。箱子上的标签不变。<br>这里的箱子内部发生了变化，但是还是这个箱子。 这就是可更改对象。</p>
<h2 id="传递可改变和不可改变对象"><a href="#传递可改变和不可改变对象" class="headerlink" title="传递可改变和不可改变对象"></a>传递可改变和不可改变对象</h2><p>举一个例子，传递不可变对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def ChangeInt( a ):</span><br><span class="line">    a = 10</span><br><span class="line"></span><br><span class="line">b = 2</span><br><span class="line">ChangeInt(b)</span><br><span class="line">print b</span><br></pre></td></tr></table></figure></p>
<p>这里的b 是多少呢？ 答案是2，而不是10.<br>–很多同学看到这里已经糊涂了，刚开始我也是，而且已经被洗脑……忘记了Perl中是怎么使用的了。<br>那么，先用箱子和球来解释一下，然后再利用Perl 的代码做一下对比，相信大家会理解的。</p>
<p>要记住一点，Python 在对待不可变对象和可变对象的态度是不同的。<br>对待不可变对象，Python 仅仅会把值传递过去，而不会传递对象本身。对待可变对象，Python 会把对象传递过去。<br>可以将Python中的函数作为一个独立的工作室，而且这个工作室只会造球，不会造箱子，如果你传过来的是一个不可修改的球，那么，工作室会自己再造一个一模一样的球，不会改动你的球和你的标签（这一点很重要，不是在球上贴了一个新标签，而是在一个工作室的异空间里造了一个同样的球，贴了同样的标签）。<br>如果传过来的是箱子，那么工作室会认为这个东西可改变，会把箱子接过去，所有的操作直接对于这个箱子进行。</p>
<p>回到本例，用球和箱子来解释就是：<br>我们创建了一个半径为2 cm 的球，标签是b。在执行这个函数时，发现是一个球，这个小工作室就会在异空间里创造一个新的（标签是什么不重要）2 cm 的球。<br>接下来的操作，都是在异空间里操作这个球，而不是我们直接直接提供的球。<br>这个时候，把标签a 也贴在这个异空间球上（传值的方式复制了变量b，a和b 都指向同一个对象）。<br>随后在函数中， a = 10。 想让标签a 指向另外一个 10 cm 的球，那么就像上面解释的那样，球不能被改变，对，即使在异空间中。<br>只能把 2 cm 球上的标签a 划掉，再重新创造一个异空间球，贴上标签a。<br>最后，当我们想访问标签b 的时候，会得到什么呢？<br>我们会发现标签b 还好好的贴在真实空间中2 cm 的球上，因此b 依然是2。</p>
<p>过程虽然比较复杂，但是相信还是比较好理解的。<br>小问题，如果将ChangeInt(a) 变为 ChangeInt(b) 呢？<br>结果是一样的，因为你的球的标签不重要，传递的是值，即这个球的属性（大小，颜色等等）。<br>等于在异空间中制造了标签为b的球，大小一样，然后又创造了一个大小为10 cm 的标签为b 的球。<br>但是在真实空间中，你的贴有标签b 的球，还是那个球，压根没变。</p>
<p>如果是Perl 的话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sub func &#123;</span><br><span class="line">        $_[0]=10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a=2;</span><br><span class="line">func($a);</span><br><span class="line">print &quot;$a\n&quot;;</span><br></pre></td></tr></table></figure></p>
<p>那么输出的又是什么呢？ 答案是10，不是2。<br>为什么？<br>在Perl中，传递到函数中的参数，都是以引用（或者说指针）的形式进行的。<br>这里在func中，@_ 数组存储了每一个输入变量，那么$<em>[0] 就是func中的第一个变量，但是传递的形式是引用（不是Python中的复制了一个球）。<br>所以，这里的$</em>[0] 其实就是$a，修改$<em>[0] 就是修改$a，两者没有任何区别。<br>换成形象的例子就是，@</em> 创建了一个花名册，包含了各个标签。根据这个花名册，想要修改哪一个标签中的内容，就直接找到对应的箱子，修改这个箱子。<br>在其中，没有生成新的球或者箱子，也没有生成新的标签，只是多一个花名册。<br>Perl 就是这么简单粗暴，所有传过来的东西都是箱子，不会重新造。</p>
<p>那么，再举一个传可变对象的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def changeme( mylist ):</span><br><span class="line">  &quot;修改传入的列表&quot;</span><br><span class="line">  mylist.append([1,2,3,4]);</span><br><span class="line">  print &quot;函数内取值: &quot;, mylist</span><br><span class="line">  return</span><br><span class="line"></span><br><span class="line"># 调用changeme函数</span><br><span class="line">mylist = [10,20,30];</span><br><span class="line">changeme( mylist );</span><br><span class="line">print &quot;函数外取值: &quot;, mylist</span><br></pre></td></tr></table></figure></p>
<p>在这个例子，两次print 的结果都是一样的： [10, 20, 30, [1, 2, 3, 4]]。<br>因为append 方法在列表后面加上了一个实际为列表的引用元素，上文中说到，列表和字典都是箱子，可以直接被操作，所以最后mylist 中的元素值也随之改变。</p>
<h1 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h1><p>调用函数时有以下四种不同的参数类型： 必备参数、关键字参数、默认参数和不定长参数。</p>
<h2 id="必备参数"><a href="#必备参数" class="headerlink" title="必备参数"></a>必备参数</h2><p>调用时必须传递的参数，如果不传递，就会报错，这个很好理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def printme( str):</span><br><span class="line">    print str;</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">printme(); #这样是错误的，因为没有传递必备参数</span><br><span class="line">mystr=&apos;test&apos;;</span><br><span class="line">printme(mystr); #这样是正确的</span><br></pre></td></tr></table></figure></p>
<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>这个很有意思，相当于指定了参数对应的是哪一个，用参数名匹配参数值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def printinfo( name, age ):</span><br><span class="line">  &quot;打印任何传入的字符串&quot;</span><br><span class="line">  print &quot;Name: &quot;, name;</span><br><span class="line">  print &quot;Age &quot;, age;</span><br><span class="line">  return;</span><br><span class="line"></span><br><span class="line">#调用printinfo函数</span><br><span class="line">printinfo( age=50, name=&quot;miki&quot; );</span><br></pre></td></tr></table></figure></p>
<p>可以看到，只要指定了参数的名字，就可以传参，使得参数的输入顺序不再有意义。</p>
<h2 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h2><p>顾名思义，设置函数参数的默认值，如果在传参的时候不传入，那么就认为是默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def printinfo( name, age = 35 ):</span><br><span class="line">  &quot;打印任何传入的字符串&quot;</span><br><span class="line">  print &quot;Name: &quot;, name;</span><br><span class="line">  print &quot;Age &quot;, age;</span><br><span class="line">  return;</span><br><span class="line">#调用printinfo函数</span><br><span class="line">printinfo( age=50, name=&quot;miki&quot; );</span><br><span class="line">printinfo( name=&quot;miki&quot; );</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，第二次调用该函数时，仅仅指定了name，而没有指定age，那么就使用了缺省参数 age=35。<br>这里要注意的问题是，如第一个例子中，调用该函数的时候指定了age，那么缺省参数age=35 就不会生效而是会被input 覆盖。</p>
<h2 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h2><p>给函数留有一定的余地，有点类似于Perl中@_的意思，只是在Python中，用*vartuple 即在变量之前加上一个星号来表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def printinfo( arg1, *vartuple ):</span><br><span class="line">  &quot;打印任何传入的参数&quot;</span><br><span class="line">  print &quot;输出: &quot;</span><br><span class="line">  print arg1</span><br><span class="line">  for var in vartuple:</span><br><span class="line">      print var</span><br><span class="line">  return;</span><br><span class="line"></span><br><span class="line">printinfo( 10 ); #调用printinfo 函数</span><br><span class="line">printinfo( 70, 60, 50 );</span><br></pre></td></tr></table></figure></p>
<p>这里的vartuple相当于一个列表，将多余的参数都放在其中，那么，在函数中自然可以遍历。</p>
<h1 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h1><p>一个迷你型的函数，只是一个表达式，不是代码块。使用方式是：  lambda [arg1 [,arg2,…..argn]]:expression</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum = lambda arg1, arg2: arg1 + arg2;    #可写函数说明</span><br><span class="line">print &quot;相加后的值为 : &quot;, sum( 10, 20 ) #调用sum函数</span><br><span class="line">print &quot;相加后的值为 : &quot;, sum( 20, 20 )</span><br></pre></td></tr></table></figure>
<p>这里，lambda 的表示稍稍有点奇怪，需要适应。但是其中的代码块是很好理解的。</p>
<h1 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h1><p>与Perl 语言类似，有全局变量和局部变量之分，在函数内部的局部变量只能内部访问，不能被作用域之外的区域访问。<br>而全局变量自然整个程序范围中都可以访问。<br>但是与Perl 不同的是，Perl 在函数内部默认也是调用全局变量，而Python则是相反，默认在函数内的变量是独立的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">total = 0;</span><br><span class="line">def sum( arg1, arg2):</span><br><span class="line">    total = arg1+arg2;</span><br><span class="line">    return total;</span><br><span class="line"></span><br><span class="line">sum(10 ,20 );</span><br><span class="line">print total;</span><br></pre></td></tr></table></figure></p>
<p>这里，得到的total 结果是0，而不是30！ 在函数sum中total 为30。这里的区别请参考前面关于传参的部分，自行体会。<br>而相似的代码，如果用Perl 实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$total=0;</span><br><span class="line"></span><br><span class="line">sub Tmp()&#123;</span><br><span class="line">  $total=$_[0]+$_[1];</span><br><span class="line">  return $total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&amp;Tmp(10,20);</span><br><span class="line">print &quot;$total\n&quot;;</span><br></pre></td></tr></table></figure></p>
<p>猜猜结果是多少？<br>答案是30，因为在Perl中，如果不声明的话，函数中的$total 就是全局变量 $total，因此是直接修改了$total，自然结果也就改变了。<br>那么，如果想要在Python中实现类似于Perl 的效果，直接使用全局变量，应该怎么做？<br>应该使用global 声明变量，即在函数中声明该变量是全局变量，在上一个例子中，即 global total。那么对于total 的赋值，就是对于全局变量进行了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在Python 的函数中，有很多细微差别是与Perl 不同，甚至相反的。<br>在Perl中对于变量的声明是比较粗放的，而在Python中更多的是面向对象编程的原则，将函数封装在一个黑箱子中，因此在设计时，就是天然隔绝的。</p>
<p>在学习过程中，一定要注意区别，多加练习，在后续的使用过程中一定要小心。使用习惯不是短期能改变的，所以切记要注意。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-Linux 与编程语言 " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.bioinfogo.tk/2018/01/12/Python 学习笔记-Part3/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kang Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BioinfoGo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/12/Python 学习笔记-Part3/" itemprop="url">Python 学习笔记-Part3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-12T16:13:30+08:00">
                2018-01-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux-与编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">Linux 与编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本次笔记，主要包括的内容是具体的数字类型的用法学习。</p>
<h1 id="数字-Number"><a href="#数字-Number" class="headerlink" title="数字 Number"></a>数字 Number</h1><p>数据类型是不能改变的，这一点与Perl 不同，在Perl中如果想要对于数字和字符串进行计算是可行的，但是在Python中数字型的变量是不可以的。<br>通过del 语法可以删除Number 对象：</p>
<blockquote>
<p>del var_a, var_b</p>
</blockquote>
<h2 id="数字类型转换"><a href="#数字类型转换" class="headerlink" title="数字类型转换"></a>数字类型转换</h2><p>最常用的是int()，long()，float()，完成常见的数字类型的转换，分别是整数型，长整数型和浮点型。<br>其次，可以将数字转换为字符串、列表、元组： str()，list()，tuple()。</p>
<h2 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h2><p>随机数太常用了，Python 提供了几个常用的函数，如下。<br>choice 函数，从序列中随机挑选一个出来。 如：</p>
<blockquote>
<p>random.choice( range(10))</p>
</blockquote>
<p>从0-9 中随机挑选一个整数出来。</p>
<p>与此类似的是randrange([start,] stop [,step])，这个也不难理解。step，即步移或者基数递增，默认是1，从start 到stop，每次递增一个step。<br>然后从中选择一个随机数。举一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">range(1,5) #为 [1,2,3,4]，不包含5</span><br><span class="line">range(1,5,2) # 为[1,3] ，因为step 为2,</span><br><span class="line">range(5) # start 默认为0，所以为[0,1,2,3,4]</span><br></pre></td></tr></table></figure></p>
<p>random()，则是从[0,1) 中随机一个数。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>在Part 1 中其实已经有所涉及了。比如字符串的位置是从0开始的，与Perl 相同。只是取范围的时候，上边界不在取值范围中。<br>比如字符串的运算与Perl 不同，连接符 和 重复输出都不同。<br>与Perl 相似，也采用反斜杠作为转义符，换行符、制表符等与Perl 也相同。</p>
<p>有意思的是，Python 提供了原样输出的参数：</p>
<blockquote>
<p>print r\n’ # print R’\n’ # 不会输出换行符，而是原样输出\n</p>
</blockquote>
<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>与Perl 需要printf 不同，在Python中直接可以利用print 进行字符串的格式化输出，用法也不太一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print &quot;My name is %s and weight is %d kg!&quot; % (&apos;Zara&apos;, 21)</span><br><span class="line">#会输出：My name is Zara and weight is 21 kg!</span><br></pre></td></tr></table></figure></p>
<p>可以看出，%s 是格式化字符串的，而%d 则是格式化整数。这里要注意，用法的格式是 print “%s” %（‘Str’）。<br>具体的，如定义宽度，可以采用”*”，“-” 可以用于左对齐等等，用到的时候可以再看。</p>
<h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>与Perl 相似，很多内建函数很有用，举一些例子：</p>
<blockquote>
<p>string.capitalize() 将字符串的第一个字符大写<br>string.count(str, beg=0,end=len(string)) 统计出现次数的函数，很有用。在string中搜索 str，并统计数目，可以指定区间。<br>string.find(str, beg=0, end=len(string)) 统计str是否包含在string中，可以搜索指定区间<br>string.join(seq) 以string 为分隔符，注意，不是以seq作为分隔符，将seq中所有元素合并为一个新的字符串<br>string.partition(str) 以str 为分割点，将string 分割为三个元素的元组：string_pre_str, str, string_post_str<br>string.replace(str1, str2, num=string.count(str1)) 将str1 替换为str2，替换的次数不超过num 次。这里num为str1 的出现次数，则是全部替换<br>string.split(str=””, num=string.count(str1)) 以str 分割string，如果指定num，则仅分割num个子字符串</p>
</blockquote>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>在前文中说过，类似于Perl 的数组，创建的方式与Perl 也类似。只是将小括号变为中括号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">print list[2]; #取得&apos;c&apos;</span><br><span class="line">del list[1];</span><br><span class="line"># 此时，list为[&apos;a&apos;,&apos;c&apos;]</span><br><span class="line">len(list) #可以获取list 的长度，为3</span><br></pre></td></tr></table></figure></p>
<p>比较特殊的一点是，可以利用del 命令来删除列表中的元素，后面的元素会自动提前。<br>列表可以利用“+” 和“*” 进行操作，前者表示组合不同的列表，而后者是重复。</p>
<h2 id="列表函数-amp-方法"><a href="#列表函数-amp-方法" class="headerlink" title="列表函数&amp;方法"></a>列表函数&amp;方法</h2><p>相比Perl，Python 提供了很多很好用的函数和方法，可以很方便的处理列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">max(list) #可以获取元素中的最大值</span><br><span class="line">min(list) #可以获取元素中的最小值</span><br><span class="line">list(seq) #将元组转换为列表</span><br><span class="line">list.append(obj) #在列表后面添加新的对象，类似于Perl中的push</span><br><span class="line">list.count(obj) #顾名思义，统计某一个元素在列表中的出现次数</span><br><span class="line">list.extend(seq) #与append不同的是，一次性加入另外一个list</span><br><span class="line">list.index(obj) #找出某一个值在列表中第一个匹配项的位置</span><br><span class="line">list.insert(index,obj) #很有用的方法，将obj 插入到列表的某一个位置</span><br><span class="line">list.pop(obj=list[-1]) #该方法用于移除list中的某一个元素，默认是最后一个元素，与Perl 相同</span><br><span class="line">list.remove(obj) #移除obj 的第一个匹配项</span><br><span class="line">list.reverse() #反向列表中的元素，即倒序排序</span><br><span class="line">list.sort([func]) #根据某一个规则进行排序，默认是根据ASCII 排序。</span><br></pre></td></tr></table></figure></p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>这一部分在前面已经稍稍介绍过，与列表的不同之处在于，建立之后元素不能修改。<br>想要操作的话，可以对于不同的元组进行组合，或者删除某一个元组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (1,2,3);</span><br><span class="line">tup2 = (&apos;abc&apos;,&apos;xyz&apos;);</span><br><span class="line">tup3 = tup1 + tup2; #此处tup3 为 (1,2,3,&apos;abc&apos;,&apos;xyz&apos;)</span><br><span class="line">tup4 = tup1 * 2; #此处tup4 为(1,2,3,1,2,3)</span><br><span class="line">del tup4; #利用 del 函数删除元组</span><br></pre></td></tr></table></figure></p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>上文中说过，与Perl 中的哈希特别相似，发挥相同的功能。<br>只是定义的方式不同，采用”:” 由键指向值。外面是利用{} 进行包围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;&apos;Name&apos;: &apos;Zara&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125;;</span><br><span class="line">#若要想取得某一个键对应的值： dict[&apos;Name&apos;]</span><br><span class="line">del dict[&apos;Name&apos;]; #想要删除某一个元素（键及值）</span><br><span class="line">dict.clear(); #清空字典中的所有条目，这个字典还是存在的</span><br><span class="line">del dict; #删除字典</span><br><span class="line">len(dict); # 计算元素的个数，即键的数目</span><br></pre></td></tr></table></figure></p>
<p>由于键不可变，所以可以为元组，但是不能为列表。</p>
<h2 id="字典的方法"><a href="#字典的方法" class="headerlink" title="字典的方法"></a>字典的方法</h2><p>作为一种灵活又强大的数据类型，自然有很多好用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dict.get(key, default=None) # 跟取值差不多，返回特定键的值，但是如果不存在的话，可以返回default</span><br><span class="line">dict.has_key(key) #与Perl中的defined $hash&#123;$key&#125; 相似，检查是否含有这个键</span><br><span class="line">dict.iterms() # 返回元组列表，即总体是一个列表，每一对键值都是一个小的元组</span><br><span class="line">dict.keys() #以列表的形式返回所有键</span><br><span class="line">dict.setdefault(key, default=None) #与get 方法相似，只是如果没有这个键的话，则会添加，并将值设置为default</span><br><span class="line">dict.update(dict2) #很有用，将dict2 的键值更新到dict中</span><br><span class="line">dict.values() #与keys 方法相似，以列表的形式返回所有值</span><br><span class="line">dict.pop(key[,default]) # pop即弹出，删除某个键所对应的值，并将值返回。</span><br></pre></td></tr></table></figure></p>
<p>总体感觉，相比Perl，Python 提供的方法功能，解决了很多痛点，在一些基本操作上会更简洁。<br>此外，要注意到与Perl 类似，Python 字典中的值可以是任意类型，所以可以是列表或者是字典，从而实现了Perl中二维哈希或者哈希数组的功能。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-Linux 与编程语言 " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.bioinfogo.tk/2017/12/13/Python 学习笔记-Part2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kang Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BioinfoGo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/13/Python 学习笔记-Part2/" itemprop="url">Python 学习笔记-Part2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-13T11:20:30+08:00">
                2017-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux-与编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">Linux 与编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>在前文的案例中其实已经用到条件语句 if， 用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if 判断条件：</span><br><span class="line">    执行语句……</span><br><span class="line">else：</span><br><span class="line">    执行语句……</span><br><span class="line"># 或者多个判断条件：</span><br><span class="line">if 判断条件1:</span><br><span class="line">    执行语句1……</span><br><span class="line">elif 判断条件2:</span><br><span class="line">    执行语句2……</span><br><span class="line">elif 判断条件3:</span><br><span class="line">    执行语句3……</span><br><span class="line">else:</span><br><span class="line">    执行语句4……</span><br></pre></td></tr></table></figure></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>与 Perl 不同的是，这里采用的不同花括号，而是”:” 开始判断后的语句部分。因此，也一定要注意缩进，这是多层判断的语句区分关键。<br>此外，elsif 变成了 elif，更加精简。（PS：程序员真懒）<br>如果执行语句简单，则可以在同一行进行执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var = 100 </span><br><span class="line">if ( var  == 100 ) : print &quot;变量 var 的值为100&quot;</span><br></pre></td></tr></table></figure></p>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h2><p>这里的while 与Perl 中的类似，基本用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 判断条件:</span><br><span class="line">    执行语句</span><br></pre></td></tr></table></figure></p>
<p>与Perl 类似，在循环中可以跳过或者跳出循环，两个命令的名字与Perl 不同。<br>跳出循环：    break    类似于 Perl 的last<br>跳过本次循环：    continue    类似于Perl 的next</p>
<p>Python 支持在while 的时候，如果条件不成立，执行 else 语句，用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count = 0</span><br><span class="line">while count &lt; 5:</span><br><span class="line">  print count, &quot; is  less than 5&quot;</span><br><span class="line">  count = count + 1</span><br><span class="line">else:</span><br><span class="line">  print count, &quot; is not less than 5&quot;</span><br></pre></td></tr></table></figure></p>
<p>这个如果是自然状态下完成了while 循环之后，并没有太大的作用，因为如果跳出了循环，自然就要执行下面的语法。<br>但值得注意的是，如果采用break跳出while循环，那么就不会执行else 中的语法。</p>
<p>还有就是，与if 相似，可以将命令写在同一行。</p>
<h1 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h1><p>Python 的用法，与PHP 类似，与Perl 的差异比较大（Perl 的for 循环更加类似于C）。一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruits = [&apos;banana&apos;, &apos;apple&apos;,  &apos;mango&apos;]</span><br><span class="line">for fruit in fruits:       # 模式 是  for xxx in xxxx</span><br><span class="line">  print &apos;当前水果 :&apos;, fruit</span><br></pre></td></tr></table></figure></p>
<p>这里的循环方式，与Perl 中的foreach 相似，逐个循环。</p>
<p>自然，也可以采用类似于Perl 中的for($i=1;$i&lt;10;$i++) 的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruits = [&apos;banana&apos;, &apos;apple&apos;,  &apos;mango&apos;]</span><br><span class="line">for index in range(len(fruits)):</span><br><span class="line">  print &apos;当前水果 :&apos;, fruits[index]</span><br></pre></td></tr></table></figure></p>
<p>这里解释一下，len(fruits)，取得了fruits 的长度，列表中的元素数目（这里为3）。然后range () 则是返回了从0 至 元素数目-1的各个数的列表。<br>即： len(fruits) 为3，range(3) 为[0, 1, 2]。 那么for 就会循环这个列表，从中取值 0,1,2。自然，fruits[index] 就可以从列表fruits 中取得对应的元素了。</p>
<p>与while 相似，可以与else 并用；同样地，如果for 是通过break 跳出的，则不会执行else 中的语句。</p>
<p>而至于嵌套循环的部分，如果学过Perl 的话，自然可以理解，用法是类似的，不再赘述。<br>此外，Python中还引入了pass 的语句，该语句为空，只是为了结构完整。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-Linux 与编程语言 " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.bioinfogo.tk/2017/12/08/Python 学习笔记-Part1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kang Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BioinfoGo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/08/Python 学习笔记-Part1/" itemprop="url">Python 学习笔记-Part1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-08T16:37:30+08:00">
                2017-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux-与编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">Linux 与编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Python 说是目前最火的语言也不为过，在生物信息的领域中，也早已盖过曾经的老大哥Perl，成为使用最广泛的脚本语言。<br>就我自己周围人的反馈而言，大体有以下几点优势：</p>
<ol>
<li>易学习，易上手。相比Perl 天书一般的符号，Python 的先天优势明显。</li>
<li>胶水语言，在多个领域均有突出的表现。</li>
<li>机器学习愈演愈烈，Python 拥有诸多的包和相关的接口，可以实现机器学习的快速上手。</li>
</ol>
<p>也是基于以上几点，也有个人对于Python 语法的好奇，决定抽时间学习一下Python。<br>以下学习均基于runoob.com 上的<a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">Python 教程</a>，在原基础上增加了一点点相关知识点Perl 与Python 的对比，仅供参考。</p>
<h1 id="基本注意点"><a href="#基本注意点" class="headerlink" title="基本注意点"></a>基本注意点</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>Python 的代码块不采用{}，而是采用缩进来进行模块的判断，代码块中缩进的空白数目必须相同。<br>一行中，可以使用多条语句，用分号分隔开即可。<br>print 默认是换行输出的，想要不换行，在变量末尾加上逗号，如 print a,</p>
<h2 id="三引号"><a href="#三引号" class="headerlink" title="三引号"></a>三引号</h2><p> “”” 可以多行输入，可以编写多行的文本，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paragraph = &quot;&quot;&quot;这是一个段落。</span><br><span class="line">包含了多个语句&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></p>
<p>也可以作为多行注释，三个双引号，或者三个单引号均可。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">这是多行注释，使用单引号。</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure></p>
<h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><p>Python 的变量不需要声明类型，这一点与Perl 不同， 有点类似于PHP。但是在使用前必须赋值，不然变量不会被创建。<br>变量不需要 “$” 符号。<br>多变量赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#多个变量同时赋值</span><br><span class="line">a = b = c = 1</span><br><span class="line">#多个变量，赋不同的值</span><br><span class="line">a, b, c = 1, 2, &quot;john&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Python 中一共有五种数据类型：</p>
<blockquote>
<p>Numbers 数字<br>String 字符串<br>List 列表<br>Tuple 元组<br>Dictionary 字典</p>
</blockquote>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>数字和字符串，比较常见，不再赘述。值得一提的是 Python中的字符串，位置与Perl相似，从0开始，而从右到左检索时，则是从-1开始。</p>
<h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>字符的截取，类似于Perl 中的substr 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;ilovepython&apos;</span><br></pre></td></tr></table></figure></p>
<p>那么，s[1:5]，则取的是love。不同的是，取到的是love，而不是lovep，因为取值的上边界不包括在范围中</p>
<h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><p>与Perl中采用 “.” 作为字符串连接符不同，Python采用的是”+“，加号。 strC = strA + strB<br>此外，重复操作也不同，Perl中是”x”，而Python 则是 “<em>“。 strAA = strA \</em> 2</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>使用最广泛，类似于Perl 中的数组，同样采用 [] 作为标识符。<br>字符串连接符也适用于列表，可以直接将不同的列表进行相加。</p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>与列表类似，但是不能二次赋值，相当于只读属性的列表，采用 () 作为标识符，标识符与Perl中的数组一样。<br>因此，一定注意区分Perl 与Python 中相应数据类型，不要搞混。</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>与Perl中的哈希类似，采用键值进行存取，标识符同样是 {}。<br>定义的方式与Perl不同，采用”:” 由key指向value。值得注意的是，如何获取字典中的所有键值？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tinydict = &#123;&apos;name&apos;: &apos;john&apos;,&apos;code&apos;:6734, &apos;dept&apos;: &apos;sales&apos;&#125;</span><br><span class="line">print tinydict.keys()</span><br><span class="line">print tinydict.values()</span><br></pre></td></tr></table></figure></p>
<p>输出的结果中，key 和value 都作为一个新的列表。</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>这部分与Perl 类似，注意到，Python 中可以取整数，运算符为 “//“，9//2 为4，这一点比Perl 采用int 更加方便。</p>
<h2 id="比较、赋值与逻辑运算符"><a href="#比较、赋值与逻辑运算符" class="headerlink" title="比较、赋值与逻辑运算符"></a>比较、赋值与逻辑运算符</h2><p>比较、赋值运算符这一部分，与Perl 完全一致，不再赘述。<br>位运算符，我目前几乎不用到，在此暂不描述。</p>
<p>至于逻辑运算符，与Perl 不同的是，不支持 “&amp;&amp;”、”||” 用以表示 and 和 or。</p>
<h2 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h2><p>这一部分与Perl不同，Python 支持从字符串、列表、元组中查找是否含有特定的序列，采用 in 和 not in 进行判断。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">list =[ 1,2,3,4,5]</span><br><span class="line">if ( a in list):</span><br><span class="line">    print &quot;Yes&quot;</span><br><span class="line">else:</span><br><span class="line">    print &quot;No&quot;</span><br></pre></td></tr></table></figure></p>
<p>结果自然是Yes。</p>
<h2 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h2><p>Python 引入了身份运算符的概念，采用 is 和 is not 进行判断。这里是检查两个标识符是否引用自同一个对象。<br>这里有一个问题，与 == 不同，is 判断的是变量的引用对象是否是同一个，而== 判断的是值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; b = a</span><br><span class="line">&gt;&gt;&gt; b is a </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; b == a</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; b = a[:]</span><br><span class="line">&gt;&gt;&gt; b is a</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; b == a</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<p>个中区别，可以通过这个案例体会一下。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.bioinfogo.tk/2017/09/30/JBrowser 基因组呈现工具的配置/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kang Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BioinfoGo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/30/JBrowser 基因组呈现工具的配置/" itemprop="url">JBrowser 基因组呈现工具的配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-30T21:05:08+08:00">
                2017-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/基因组学/" itemprop="url" rel="index">
                    <span itemprop="name">基因组学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JBrowser 一款具有很高易用性的基因组浏览器，与UCSC Genome Browser 相似。<br>但是通过简单对比其配置过程，可以发现JBrowser 更容易配置，自由度更高。所以为了呈现非模式生物的基因组，利用JBrowser是一个很不错的选择。<br>我在一年多之前配置过该工具，效果令人满意。近来需要在另外一台服务器上配置，所以将大体的配置过程总结整理一下。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下载获取JBrowser的最新版本，官方地址在此 –&gt; <a href="http://jbrowse.org/jbrowse-1-12-3/" target="_blank" rel="noopener">Download</a><br>unzip 解压一下，进入该目录之后：</p>
<blockquote>
<p>./setup.sh</p>
</blockquote>
<p>该过程可能耗时比较长（视你本地的perl 安装包的安装情况以及网速而定），可能需要1~2个小时。<br>可以通过查看setup.log的方式，检查安装进度。<br>配置完成之后，可以通过访问：</p>
<blockquote>
<p><a href="http://your.jbrowse.root/index.html?data=sample_data/json/volvox" target="_blank" rel="noopener">http://your.jbrowse.root/index.html?data=sample_data/json/volvox</a></p>
</blockquote>
<p>来检查你的JBrowser 是否安装成功。<br>这里，your.jbrowse.root 替换为：你的网站的根目录/JBrowse-1.12.3/ （版本不同，自然文件夹名字也不同）</p>
<h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p>在这里，我为了美观以及加强对于该程序的理解，没有直接在安装目录下配置基因组的信息，而是在网站根目录下新建了一个目录genome，存放数据。</p>
<h2 id="不同目录下配置基因组（可选）"><a href="#不同目录下配置基因组（可选）" class="headerlink" title="不同目录下配置基因组（可选）"></a>不同目录下配置基因组（可选）</h2><p>即JBrowse-1.12.3 和genome 是并列的关系。<br>首先，将JBrowser目录下的jbrowse.conf 、jbrowse_conf.json 和index.html 拷贝到genome 目录下并修改。<br>index.html 在默认情况下，如果打开这个网页的话，是全屏显示JBrowser的，而我为了协调不同网页的呈现效果，对于index.html 进行了修改：</p>
<blockquote>
<p>在javascript 的段落之前增加 header  等部分，与网站下的其他网页保持一致的header 效果</p>
</blockquote>
<p>重点在于，既然修改了index 的位置，就要在其中对应的修改JavaScript 文件的位置，不然JBrowser 无法找到对应的配置文件。<br>举一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;../JBrowse-1.12.3/src/dojo/dojo.js&quot;&gt;&lt;/script&gt; #本来是src/dojo/dojo.js</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;../JBrowse-1.12.3/src/JBrowse/init.js&quot;&gt;&lt;/script&gt; #本来是src/JBrowse/init.js</span><br></pre></td></tr></table></figure></p>
<p>这样的修改不止这两处，请仔细阅读index.html 文件，在其中修改。<br>但是这里我发现网页所需要的img，并没有修改目录位置的地方，只能通过把JBrowser中的img 文件夹复制到genome 下。</p>
<h2 id="基因组序列的导入"><a href="#基因组序列的导入" class="headerlink" title="基因组序列的导入"></a>基因组序列的导入</h2><p>JBrowser 中有比较完善的序列导入工具，导入很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../JBrowse-1.12.3/bin/prepare-refseqs.pl --fasta genome.fasta</span><br></pre></td></tr></table></figure></p>
<p>在该目录下，会形成data 文件夹，其中会包含seq 文件夹，刚刚导入的基因组就已经以json 数据的格式保存完成了。<br>可以通过该网址访问一下试试：</p>
<blockquote>
<p> <a href="http://your.jbrowse.root/genome/index.html" target="_blank" rel="noopener">http://your.jbrowse.root/genome/index.html</a></p>
</blockquote>
<p>如果不出意外的话，会发现基因组已经可以呈现了。</p>
<h2 id="基因组注释和比对文件等track的导入"><a href="#基因组注释和比对文件等track的导入" class="headerlink" title="基因组注释和比对文件等track的导入"></a>基因组注释和比对文件等track的导入</h2><p>gff、bed 和bam 文件等都是可以导入到JBrowser中的，接下来，我们先尝试导入基因的注释结果。<br>为了分层次显示，我建议先导入基因的gff注释，而将其中的transcript、CDS、UTR、exon等line 去除，这样的话指定显示起来更加方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../JBrowse-1.12.1/bin/flatfile-to-json.pl -gff your_gene_annotation.gff --trackType CanvasFeatures --trackLabel Gene</span><br></pre></td></tr></table></figure></p>
<p>会发现在data中又多了一个track 文件夹，还多了trackList.json。该文件是用于自定义track 极其重要的conf文件。<br>在此，分享我的一个conf 文件，方便解释各项参数的意义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tracks&quot; : [</span><br><span class="line">      &#123; #第一个是genome 的DNA 序列</span><br><span class="line">        &quot;storeClass&quot; : &quot;JBrowse/Store/Sequence/StaticChunked&quot;,</span><br><span class="line">        &quot;chunkSize&quot; : 20000,</span><br><span class="line">        &quot;urlTemplate&quot; : &quot;seq/&#123;refseq_dirpath&#125;/&#123;refseq&#125;-&quot;,</span><br><span class="line">        &quot;label&quot; : &quot;DNA&quot;,</span><br><span class="line">        &quot;type&quot; : &quot;SequenceTrack&quot;,</span><br><span class="line">        &quot;category&quot; : &quot;1. Reference sequence&quot;, #类别，会在网页上分栏显示，顺序根据名字的排序结果排列。因此我加了前缀序号</span><br><span class="line">        &quot;key&quot; : &quot;Reference sequence&quot; #条目的显示名字</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;style&quot; : &#123;</span><br><span class="line">            &quot;className&quot; : &quot;feature2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;key&quot; : &quot;1. Protein-coding gene&quot;,</span><br><span class="line">        &quot;storeClass&quot; : &quot;JBrowse/Store/SeqFeature/NCList&quot;,</span><br><span class="line">        &quot;trackType&quot; : &quot;CanvasFeatures&quot;,</span><br><span class="line">        &quot;urlTemplate&quot; : &quot;tracks/Gene/&#123;refseq&#125;/trackData.json&quot;,</span><br><span class="line">        &quot;compress&quot; : 0,</span><br><span class="line">        &quot;category&quot; : &quot;2. Gene Annotation&quot;,</span><br><span class="line">        &quot;label&quot; : &quot;Gene&quot;,</span><br><span class="line">        &quot;type&quot; : &quot;FeatureTrack&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;style&quot; : &#123;</span><br><span class="line">            &quot;className&quot; : &quot;transcript&quot;,</span><br><span class="line">            &quot;color&quot; : &quot;#EC7063&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;key&quot; : &quot;2. Coding sequence&quot;,</span><br><span class="line">        &quot;storeClass&quot; : &quot;JBrowse/Store/SeqFeature/NCList&quot;,</span><br><span class="line">        &quot;trackType&quot; : &quot;CanvasFeatures&quot;,</span><br><span class="line">        &quot;urlTemplate&quot; : &quot;tracks/Coding-sequence/&#123;refseq&#125;/trackData.json&quot;,</span><br><span class="line">        &quot;compress&quot; : 0,</span><br><span class="line">        &quot;category&quot; : &quot;2. Gene Annotation&quot;,</span><br><span class="line">        &quot;type&quot; : &quot;CanvasFeatures&quot;,</span><br><span class="line">        &quot;label&quot; : &quot;Coding sequence&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">  ],</span><br><span class="line">  &quot;formatVersion&quot; : 1</span><br></pre></td></tr></table></figure></p>
<p>然后，可以导入transcript（包含exon-intron等信息）的gff，这里以transcript 为主，其他的信息如exon、UTR等，设置parent= 对应的transcript 即可。<br>导入的命令类似，不再赘述。</p>
<h1 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h1><p>在完成基因组的基本呈现之后，有很多进阶功能可以实现，我也仅仅尝试了其中一小部分。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>在JBrowser中，可以通过构建index 的方式，使得可以在网页中的搜索框中搜索相关的tracks<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generate-names.pl --incremental</span><br></pre></td></tr></table></figure></p>
<p>增加这个incremental 的参数，是可以对于增加的track 进行index。</p>
<h2 id="删除tracks"><a href="#删除tracks" class="headerlink" title="删除tracks"></a>删除tracks</h2><p>不仅可以在conf中直接去掉对应的track 记录（–trackLabel），还可以完全的删除这个track（–delete)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove-track.pl --delete transcript</span><br></pre></td></tr></table></figure></p>
<h1 id="问题与解决方案"><a href="#问题与解决方案" class="headerlink" title="问题与解决方案"></a>问题与解决方案</h1><p>在新增tracks之后，采用 incrementall 进行增加，可能报错“Error reading from name store”。<br>这时可以删除在json中的新增tracks 的记录，然后重新运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">generate-names.pl </span><br><span class="line">generate-names.pl --incremental</span><br></pre></td></tr></table></figure></p>
<p>可能会解决该问题。<br>网上提供的方案是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generate-names.pl --hashBits</span><br></pre></td></tr></table></figure></p>
<p>但是在我的操作中无效。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>JBrowser的功能极其强大，自由度很高，上述仅仅是一些基本的用法。<br>随着使用的加深，后续本文章会持续更新。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.bioinfogo.tk/2017/07/07/Circlator 环化基因组/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kang Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BioinfoGo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/07/Circlator 环化基因组/" itemprop="url">Circlator 环化拼接的基因组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-07T09:35:05+08:00">
                2017-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/基因组学/" itemprop="url" rel="index">
                    <span itemprop="name">基因组学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Circlator 是一个自动化的基因组环化工具，其利用长序列作为数据基础，根据拼接的结果对序列进行环化，并修正其中可能的错误。<br>值得注意的是，该工具并不是ab inito 的拼接工具，而是处理拼接的结果，产生正确的环形DNA 结构。<br>其优势是，在甚至没有overlap 的情况下，也可以进行环化。<br>相关的文章发表在Genome Biology，详见<a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-015-0849-0" target="_blank" rel="noopener">这里</a>。</p>
<p>该程序通过将reads 比对到已有的拼接序列末端上，形成新的拼接，然后在其中鉴定可能的环化序列，并对其中可能的重复部分进行清除。最后，根据提供的基因，确定其起点。</p>
<h1 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>该程序依赖以下的工具包：</p>
<ol>
<li>BWA version &gt;= 0.7.12</li>
<li>prodigal version &gt;= 2.6</li>
<li>SAMtools (versions 0.1.9 to 1.3)</li>
<li>MUMmer version &gt;= 3.23</li>
<li>Canu and/or SPAdes. SPAdes version 3.6.2 or higher is required, but 3.7.1 is recommended (marginally gave the best results on NCTC data from the Circlator publication, tested on all SPAdes versions 3.6.2-3.9.0).</li>
</ol>
<p>其中 BWA 是常见的序列比对工具，prodigal 是原核生物的基因预测工具，SAMtools 是常用的比对和序列处理工具，MUMmer 是老牌的长序列比对工具，Canu/SPAdes 是三代测序的拼接工具。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载github中的最新release，然后解压后测试一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 setup.py test</span><br></pre></td></tr></table></figure></p>
<p>如果没有问题的话，进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3 setup.py install</span><br><span class="line">#检查依赖包是否都可用？</span><br><span class="line">circlator progcheck</span><br></pre></td></tr></table></figure></p>
<p>在安装prodigal 过程中，如果遇到“FATAL: kernel too old”的错误，重新下载工具的source 文件，重新编译即可。<br>此外，要注意的是，python的版本不能低于3.0，否则会报错。如果系统版本低于3.0，可以重新安装一个新版的python<br>Python 的安装过程很简单，可以参考这个<a href="http://www.csuldw.com/2016/05/06/2016-05-06-python-and-pip/" target="_blank" rel="noopener">教程</a>。</p>
<h2 id="实践与问题"><a href="#实践与问题" class="headerlink" title="实践与问题"></a>实践与问题</h2><p>在一个redhat服务器上安装的时候，在安装其中一个工具包pysam 的时候，总是报错：</p>
<blockquote>
<p>cc1: error: unrecognized command line option “-Wno-error=declaration-after-statement”</p>
</blockquote>
<p>查阅相关的<a href="http://bugs.python.org/issue21121" target="_blank" rel="noopener">解决方案</a>，依然无法解决问题，所以无法配置。<br>而在另外一台较新的centOS服务器上配置的时候，除了遭遇过无权限安装python 包（更改prefix 即可）之外，没有遇到大的问题，比较顺利的完成。<br>推测还是因为gcc 的版本较低引起的问题，尽管在redhat上已经配置了gcc47。</p>
<h1 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h1><p>该程序需要的参数较少，简单来说，仅仅需要以下三项：</p>
<ol>
<li>拼接的基因组文件，fasta 格式</li>
<li>修正过后的reads 文件，fasta或者fastq 格式均可。该文件在多数的三代测序分析工具如HGAP等中会产生，并作为中间文件。</li>
<li>输出目录</li>
</ol>
<p>该程序可以分阶段运行，如果运行”all” 的话，则是运行全部的流程。</p>
<p>默认情况下，该程序是采用SPAdes 进行拼接处理。<br>值得注意的是，在最后的起点锚定阶段，该程序默认采用dnaA的序列作为起点。但是该基因是一个细菌中较为保守且靠近复制起点的基因，如果分析的对象是真核生物该基因就不适用了。我采用的ATP6（真菌，cox2 也可以），其他物种请查资料确定。<br>该基因的序列可以利用以下参数输入：</p>
<blockquote>
<p>–genes_fa FILENAME</p>
</blockquote>
<p>另外一个需要注意的问题是，这里要提供的拼接基因组序列，我认为最好预处理一下，对于真核生物而言，很多序列是已知的染色体序列片段，并不需要进行环化分析，可以剔除这些序列，仅仅保留那些可能的线粒体序列即可。<br>当然，对于具有环形基因组的原核生物则不需要处理。</p>
<p>一个常见的运行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">circlator all --threads 15 assembly.fa corrected.fastq output_circlator</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.bioinfogo.tk/2017/06/01/Github Pages+Hexo/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kang Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BioinfoGo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/01/Github Pages+Hexo/" itemprop="url">Github Pages + Hexo 构建静态blog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-01T08:30:05+08:00">
                2017-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index">
                    <span itemprop="name">Web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><h2 id="本地首次配置"><a href="#本地首次配置" class="headerlink" title="本地首次配置"></a>本地首次配置</h2><p>本地配置node.js，以及git，这些直接在官网就可以下载，都是直接点击下一步安装。<br>本地配置git的用户名与邮箱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name yourgitname</span><br><span class="line">git config --global user.name yourgit@email.com</span><br></pre></td></tr></table></figure></p>
<p>随后，为了与在线的github连接，需要配置ssh，并将生成的公钥粘贴到你的github账户中。<br>本地配置ssh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;yourgit@email.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>成功后，在系统盘的user/your_user_name中找到.ssh文件夹，打开其中的id_rsa.pub文件，将所有内容复制。<br>接着，打开你的github 设置页页面，点击SSH and GPG keys，新建一个ssh key，将刚刚拷贝的内容粘贴过去即可。<br>这样的话，就可以在本地连接到你的github账号了，可以测试一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>
<p>如果显示成功的话，就说明配置完成了。</p>
<p>然后，在管理员命令行下，利用npm安装hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">#等到安装成功后，运行：</span><br><span class="line">npm install hexo --save</span><br><span class="line">#测试是否安装成功：</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure></p>
<p>成功后，可以开始配置hexo了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#初始化：</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure></p>
<h2 id="多终端的配置"><a href="#多终端的配置" class="headerlink" title="多终端的配置"></a>多终端的配置</h2><p>如果想要在不同的终端都可以编写blog并上传，可以在多台电脑上配置git和node.js 等。<br>原理是：在第一台电脑上上传网站源代码到github 的另外一个repo上，然后在各个电脑上克隆代码，修改之后，将源代码再次保存在github上。<br>同时将修改后的网站，再次生成和上传。<br>中间遇到很多问题，最终采用了<a href="http://wangmuduo.com/2016/04/02/hexo-change-os/" target="_blank" rel="noopener">Hexo 换终端/换电脑小记</a>的教程。<br>具体来说，对于source，theme等文件夹以及yml等配置文件，采用单独保存到一个repo 的方式进行保存。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>利用npm安装hexo时候，注意以管理员的身份进行，不然的话可能报错无法找到npm（其实是权限的问题）</li>
</ul>
<h1 id="问题及解决方案"><a href="#问题及解决方案" class="headerlink" title="问题及解决方案"></a>问题及解决方案</h1><h2 id="hexo-module无法找到"><a href="#hexo-module无法找到" class="headerlink" title="hexo module无法找到"></a>hexo module无法找到</h2><p>在首次进行hexo g 的时候，报错：</p>
<blockquote>
<p>Cannot find module ‘C:\Program FIles\Git\node_modules\hexo-cli\bin\hexo’</p>
</blockquote>
<p>在网上查了半天，发现是由于这个module 在Git目录下没有找到导致的，解决方案如下：<br>在C盘中找到Users_your_name_\AppData\Roaming\npm\node_modules\hexo-cli 这个文件夹<br>然后将其中的node_modules 文件夹拷贝到Git 安装目录下，即可。</p>
<h2 id="本地server-无法访问"><a href="#本地server-无法访问" class="headerlink" title="本地server 无法访问"></a>本地server 无法访问</h2><p>在我这里，是由于端口已经被占用导致的，更换端口即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -p 9966</span><br></pre></td></tr></table></figure></p>
<h2 id="CNAME-大小写无法区分"><a href="#CNAME-大小写无法区分" class="headerlink" title="CNAME 大小写无法区分"></a>CNAME 大小写无法区分</h2><p>在source下建立了CNAME文件，对于Pages进行了重定向，但上传到github后发现变成了小写。<br>因而导致了Github无法识别改文件，无法完成重定向。</p>
<p>解决方案：<br>先在Github上删除小写的cname文件<br>在你的clone 目录下，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.ignorecase false</span><br></pre></td></tr></table></figure></p>
<p>将ignorecase 设置为false，就可以区分大小写。但是在笔者的实践中，这样做无效。<br>估计是因为服务器端的信息还是没有更改。<br>最终问题的解决参考了<a href="http://1mhz.me/2015/hexo-deploy-case-sensitive/" target="_blank" rel="noopener">Yizhao He’s Notes</a><br>进入deploy_git/.git目录，修改其中的config文件，将ignorecase= ture 改为ignorecase= false<br>然后，删除整个deploy_git 文件夹，之后同步清空Github 上的信息，这一步很重要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#在.deploy_git目录下</span><br><span class="line">git commit -m &apos;clean all file&apos;</span><br><span class="line">git push</span><br><span class="line">#回到上一目录，再次进行部署</span><br><span class="line">cd ..</span><br><span class="line">hexo clean</span><br><span class="line">hexo deploy -g</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.bioinfogo.tk/2017/05/26/GlimmerHMM 安装与使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kang Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BioinfoGo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/GlimmerHMM 安装与使用/" itemprop="url">GlimmerHMM 的安装与使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-26T11:30:01+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/基因组学/" itemprop="url" rel="index">
                    <span itemprop="name">基因组学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>GlimmerHMM 是一款基于GHMM（Generalized Hidden Markov Model）的基因预测工具，其中整合了GeneSplicer中分析剪切位点的方法。<br>与其他基因预测方法类似，需要首先进行training。</p>
<h1 id="安装和基本用法"><a href="#安装和基本用法" class="headerlink" title="安装和基本用法"></a>安装和基本用法</h1><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>本工具提供了两种使用方法，既可以采用他们直接编译好的程序运行，也可以自己编译，直接再source中make即可。难度较低。<br><a href="ftp://ccb.jhu.edu/pub/software/glimmerhmm/GlimmerHMM-3.0.4.tar.gz" target="_blank" rel="noopener">官网下载链接</a><br>如果在运行中遇到了GLIBC的版本问题，重新在source中和train中进行make编译即可。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>在bin目录下，有三个程序：</p>
<ul>
<li>glimmerhmm_linux    32位的程序</li>
<li>glimmerhmm_linux_x86_64    64位的程序</li>
<li>glimmhmm.pl    提供了一个简单的perl script，提高易用性</li>
</ul>
<p>而在train中，则主要是与training 相关的，重要的程序是：</p>
<ul>
<li>trainGlimmerHMM</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="training-过程"><a href="#training-过程" class="headerlink" title="training 过程"></a>training 过程</h2><p>虽然相似物种的结果往往不差，但是为了提高预测的准确性，最好是采用本物种的数据进行training。<br>对于训练集的要求，与其他程序类似，自然是越准确越好，最好是收集实验证实的基因。<br>如果不可行的话，可以通过将预测的长的ORF（500bp以上）的蛋白与nr数据库比较，来获取同源蛋白。</p>
<h3 id="training-的相关命令"><a href="#training-的相关命令" class="headerlink" title="training 的相关命令"></a>training 的相关命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainGlimmerHMM &lt;mfasta_file&gt; &lt;exon_file&gt; [optional_parameters]</span><br></pre></td></tr></table></figure>
<p>两个主要的输入文件，都是fasta 格式</p>
<p>&lt;mfasta_file&gt;    是包含训练集基因的序列</p>
<p>&lt;exon_file&gt;    是&lt;mfasta_file&gt;中外显子的位置，格式如下，同一个序列上的不同基因，采用一个空行进行分割：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seq1 5 15</span><br><span class="line">seq1 20 34</span><br><span class="line"> </span><br><span class="line">seq1 50 48</span><br><span class="line">seq1 45 36</span><br><span class="line"> </span><br><span class="line">seq2 17 20</span><br></pre></td></tr></table></figure></p>
<p>显而易见，seq1上有两个基因，一个正链，一个负链。<br>训练集中最少要包括50个基因，如果不够的话，则会报错退出。</p>
<h3 id="training-中的调参"><a href="#training-中的调参" class="headerlink" title="training 中的调参"></a>training 中的调参</h3><p>一些阈值的改变可能会进一步提高预测的精度。<br>默认情况下，该程序会不断尝试在不同阈值下的假阳性和假阴性率，将在假阳性率的幅度变化小于1%时的阈值，作为最终使用的阈值。<br>当然，用户也可以自己设定假阳性和假阴性率，从而更加灵活的确定阈值。<br>最重要的是isochores 的设定，如果没有分区的话，则在config.file中仅有一行：</p>
<blockquote>
<p>C+G &lt;= 100 train_0_100.cfg</p>
</blockquote>
<p>isochores的意思是，目的序列中的基因可以分为两个区间，比如一个是0-40%，一个是40-100%d GC含量。两个区间的参数可以分别设置。</p>
<p>在运行training 之后，得到的参数文件夹中，对于acceptor site、donor site 、ATG等等都有测试阈值的结果文件。<br>想要调整这些阈值，可以在不同的false.*** 文件中比较在不同阈值下的假阳性和假阴性的水平，择优进行选择。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>在笔者的实践中，发现默认采用的阈值选择方法，其假阳性率还是很高的。<br>比如在acceptor 的数据中（false.acc ）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> Threshold     False negatives     False positives</span><br><span class="line">-11.704275         0 (  0.00% )        20278 ( 56.36% )</span><br><span class="line">-11.618576         1 (  0.04% )        20195 ( 56.13% )</span><br><span class="line"> -9.756974         2 (  0.09% )        18140 ( 50.42% )</span><br><span class="line"> -9.098565         3 (  0.13% )        17418 ( 48.41% )</span><br><span class="line"> -8.441363         4 (  0.18% )        16573 ( 46.06% )</span><br><span class="line"> -8.241980         5 (  0.22% )        16298 ( 45.30% )</span><br><span class="line"> -8.121769         6 (  0.26% )        16132 ( 44.84% )</span><br><span class="line"> -7.312788         7 (  0.31% )        14935 ( 41.51% )</span><br><span class="line"> -6.644487         8 (  0.35% )        13960 ( 38.80% )</span><br><span class="line"> -6.363057         9 (  0.40% )        13564 ( 37.70% )</span><br><span class="line"> -6.324996        10 (  0.44% )        13493 ( 37.50% )</span><br><span class="line"> -6.116153        11 (  0.48% )        13138 ( 36.52% )</span><br><span class="line"> -6.006301        12 (  0.53% )        12981 ( 36.08% )</span><br><span class="line"> -5.802363        13 (  0.57% )        12696 ( 35.29% )</span><br><span class="line"> -5.404492        14 (  0.62% )        12089 ( 33.60% )</span><br><span class="line"> -5.074301        15 (  0.66% )        11606 ( 32.26% )</span><br><span class="line"> -5.070013        16 (  0.70% )        11598 ( 32.24% )</span><br></pre></td></tr></table></figure></p>
<p>第一个和第二个阈值造成的假阳性相差仅有0.23%，但是如果继续调高阈值的话，假阳性迅速减少了6%。<br>所以需要根据该结果酌情调整<br>笔者测试的设定是，当最后一次出现假阳性减少1%之后的那个阈值，这个值可以用一行perl script 搞定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &apos;next if(/Threshold/);my @arr=split /\s+/;$size=$data-$arr[8];$data=$arr[8];if($size&gt;1)&#123;print;&#125;&apos; false.atg</span><br></pre></td></tr></table></figure></p>
<p>这样确定后，在train_0_100.cfg中修改对应的阈值（笔者在此仅采用了一个isoshore，所以仅设置这个就可以）<br>这样，参数的设置就完成了。（阈值更改的效果见后面的讨论）</p>
<h2 id="预测过程"><a href="#预测过程" class="headerlink" title="预测过程"></a>预测过程</h2><p>该程序的预测特别快，比以快著称的snap 还要快很多。</p>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><p>对其中的一些参数进行解释：</p>
<blockquote>
<p>-o file_name     Print output in file_name; if n&gt;1 for top best predictions, output is in file_name.1, file_name.2, … , file_name.n f<br>-n n             Print top n best predictions</p>
</blockquote>
<p>因为同一条序列可以有不同的预测方案，因此可以输出多个预测方案的结果。<br>默认情况下，与其他预测工具一样，给出唯一的结果。此参数意义不大，可以用于测试不同方案的结果，对比一下。</p>
<h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p>glimmerhmm_linux_x86_64 或者glimmerhmm_linux 仅仅可以对于单个DNA 序列运行，即使输入的是一个multifasta文件，也仅仅会分析第一条序列。<br>而提供的glimmhmm.pl，对于参数的支持很差，并不能读入参数。</p>
<p>在此基础上，笔者对于该script 进行了修改，形成了<a href="/upload/glimmhmm_modify.pl">glimmhmm_modify.pl</a><br>主要增加了对于multi-fasta 和多参数的支持，由于时间关系，写的并不完善，如果遇到bug，请阅读代码修改或者与我联系。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>笔者以一种真菌为对象，利用该工具进行了基因的预测，结果发现，其表现与SNAP相当或略差，其优势是运行速度快，但也只剩下快了。<br>存在的问题是，无法利用各种hints 辅助预测，对于基因和基因的判断不够准确，经常错误的将基因连接或者分开。</p>
<p>从结果的对比来看，修改阈值后的结果其错误率明显高于默认值。<br>因此，<strong>在没有把握的情况下，请不要大幅度改动阈值</strong>。如果改动的话，一定要对比结果的差异。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-杂谈 " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.bioinfogo.tk/2017/05/26/hello-world/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kang Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BioinfoGo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/hello-world/" itemprop="url">Hello, BioinfoGo!</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-26T08:40:30+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="建站目的"><a href="#建站目的" class="headerlink" title="建站目的"></a>建站目的</h1><p>很早就萌发了建立一个生物信息小站的想法，如今总算是万里长征第一步。</p>
<p>生物信息学是一门新兴的交叉学科，兴起于计算机技术的发展，近年来已经成为研究和解决生物学问题的热门学科。生信身兼研究和服务的双重职能，在这个大数据时代必将有更加广阔的发展空间。</p>
<p>笔者有幸在一片懵懂中，在2013年时进入该领域，一路走来虽然跌跌撞撞，但也算有所收获。<br>在此希望能够与各位分享生信路中的学习心得与技术知识，共同学习，与君共勉。</p>
<h1 id="Github-Pages-Hexo"><a href="#Github-Pages-Hexo" class="headerlink" title="Github Pages + Hexo"></a>Github Pages + Hexo</h1><p>本网站是在Github Pages提供的基础上，利用Hexo 搭建而成。<br>在该过程中，大体参考了<a href="https://xuanwo.org/2015/03/26/hexo-intor/" target="_blank" rel="noopener">Xuanwo’s Blog</a>的教程。</p>
<p>当然中间遇到的一些坑，以后有时间会填上，期望能给后来者一些小小的帮助。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="Kang Zhang">
          <p class="site-author-name" itemprop="name">Kang Zhang</p>
           
              <p class="site-description motion-element" itemprop="description">Go, Bioinfo, Go!</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/1935924171" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhang-kang-81" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kang Zhang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user">Total users:</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye">Total visited</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
